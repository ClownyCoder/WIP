local config = {
    ["HeaderWidth"] = 250,
    ["AccentColor"] = Color3.fromRGB(0.0,0,0),
    ["PrimaryColor"] = Color3.fromRGB(20,20,20),
    ["SecondaryColor"] = Color3.fromRGB(25,25,25),
    ["AccentColor"] = Color3.fromRGB(50,50,50),
    ["TextColor"] =  Color3.new(1,1,1)
}

local gui = loadstring(game:HttpGet("https://raw.githubusercontent.com/ClownyCoder/Somesource/refs/heads/main/Somesource"))():Init(config,game.CoreGui)

gui:CreateCategory("Exit"):CreateButton("Click to exit the library",function() gui:CleanUp() end)

local lpg = gui:CreateCategory("Local Player")

lpg:CreateSlider("Walk Speed", function(ws) game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = ws end,0,1000,nil,true,game.Players.LocalPlayer.Character.Humanoid.WalkSpeed)
lpg:CreateSlider("Jump Power", function(jp) game.Players.LocalPlayer.Character.Humanoid.JumpPower = jp end,0,1000,nil,true,game.Players.LocalPlayer.Character.Humanoid.JumpPower)
lpg:CreateButton("Force Field", function() Instance.new("ForceField",game.Players.LocalPlayer.Character) end)

Com = gui:CreateCategory("Combat")

local aimbotState = {
    circle = nil,
    radius = 120,
    dynamicColor = false,
    showFov = true,
    enabled = false,
    autoLock = false,
    teamCheck = true,
    locking = false,
    currentTarget = nil,
    lockConfirmed = false,
    settingsInitialized = false,
    settingsObjects = {}
}

local holdingKey = false
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

Com:CreateSwitch("Aimbot", function(enabled)
    aimbotState.enabled = enabled

    -- Create FOV Circle once
    if not aimbotState.circle then
        local circle = Drawing.new("Circle")
        circle.Thickness = 1.5
        circle.Transparency = 1
        circle.Filled = false
        circle.Color = Color3.new(1, 1, 1)
        circle.Radius = aimbotState.radius
        circle.Visible = false
        aimbotState.circle = circle

        -- FOV follow mouse
        RunService.RenderStepped:Connect(function()
            aimbotState.circle.Position = UserInputService:GetMouseLocation()
            aimbotState.circle.Radius = aimbotState.radius
            aimbotState.circle.Visible = aimbotState.enabled and aimbotState.showFov
        end)

        -- Aimbot tracking
        RunService.RenderStepped:Connect(function()
            if not aimbotState.enabled then return end

            local mousePos = UserInputService:GetMouseLocation()
            local closest = nil
            local shortest = math.huge

            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                    if aimbotState.teamCheck and player.Team == LocalPlayer.Team then continue end
                    local head = player.Character.Head
                    local pos, onScreen = Camera:WorldToViewportPoint(head.Position)
                    local dist = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if onScreen and dist < shortest and dist < aimbotState.radius then
                        shortest = dist
                        closest = head
                    end
                end
            end

            if aimbotState.autoLock then
                if closest and not aimbotState.locking and not aimbotState.lockConfirmed then
                    -- Animate toward target ONCE
                    aimbotState.locking = true
                    aimbotState.currentTarget = closest

                    coroutine.wrap(function()
                        local duration = 0.2
                        local step = 0.05
                        for i = 0, 1, step / duration do
                            if not aimbotState.autoLock then break end
                            local goal = CFrame.new(Camera.CFrame.Position, aimbotState.currentTarget.Position)
                            Camera.CFrame = Camera.CFrame:Lerp(goal, i)
                            task.wait(step)
                        end
                        aimbotState.locking = false
                        aimbotState.lockConfirmed = true
                    end)()
                end

                -- After animation, hard lock
                if aimbotState.lockConfirmed and aimbotState.currentTarget and aimbotState.currentTarget.Parent then
                    Camera.CFrame = CFrame.new(Camera.CFrame.Position, aimbotState.currentTarget.Position)
                end

                -- Lost target
                if not closest then
                    aimbotState.currentTarget = nil
                    aimbotState.lockConfirmed = false
                    aimbotState.locking = false
                end

                if aimbotState.dynamicColor then
                    aimbotState.circle.Color = closest and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
                end
            elseif holdingKey and closest then
                -- Manual aiming
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, closest.Position)
                if aimbotState.dynamicColor then
                    aimbotState.circle.Color = Color3.new(1, 0, 0)
                end
            else
                if aimbotState.dynamicColor then
                    aimbotState.circle.Color = Color3.new(1, 1, 1)
                end
            end
        end)
    end

    -- GUI Settings
    if not aimbotState.settingsInitialized then
        aimbotState.settingsInitialized = true

        table.insert(aimbotState.settingsObjects, Com:CreateSlider("FOV Radius", function(val)
            aimbotState.radius = val
        end, 50, 1000, nil, true, aimbotState.radius))

        table.insert(aimbotState.settingsObjects, Com:CreateSwitch("Dynamic Color", function(toggle)
            aimbotState.dynamicColor = toggle
        end))

        table.insert(aimbotState.settingsObjects, Com:CreateSwitch("Show FOV Circle", function(toggle)
            aimbotState.showFov = toggle
            if aimbotState.circle then
                aimbotState.circle.Visible = toggle and aimbotState.enabled
            end
        end))

        table.insert(aimbotState.settingsObjects, Com:CreateSwitch("Auto-Lock", function(toggle)
            aimbotState.autoLock = toggle
            aimbotState.lockConfirmed = false
            aimbotState.currentTarget = nil
            aimbotState.locking = false
        end))

        table.insert(aimbotState.settingsObjects, Com:CreateSwitch("Team Check", function(toggle)
            aimbotState.teamCheck = toggle
        end))
    end

    -- Show/hide setting UIs
    for _, setting in pairs(aimbotState.settingsObjects) do
        if setting and setting.Frame then
            setting.Frame.Visible = enabled
        end
    end

    -- Hide circle if off
    if aimbotState.circle then
        aimbotState.circle.Visible = enabled and aimbotState.showFov
    end

    print("ðŸŽ¯ Aimbot is now " .. (enabled and "Enabled" or "Disabled"))
end)

-- Manual key for aimbot (optional)
UserInputService.InputBegan:Connect(function(input, gpe)
    if input.UserInputType == Enum.UserInputType.MouseButton2 and not gpe then
        holdingKey = true
    end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
    if input.UserInputType == Enum.UserInputType.MouseButton2 and not gpe then
        holdingKey = false
    end
end)


Bla = gui:CreateCategory("Blatant")

Ren = gui:CreateCategory("Render")

local espState = {
    enabled = false,
    settingsInitialized = false,
    settingsObjects = {},
    dynamicColor = false,
    showBoxes = true,
    thickness = 1.5,
    boxes = {}
}

Ren:CreateSwitch("ESP", function(enabled)
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera
    local LocalPlayer = Players.LocalPlayer

    espState.enabled = enabled

    -- Function to clear ESP boxes
    local function clearESP()
        for _, box in pairs(espState.boxes) do
            if box and box.Remove then
                box:Remove()
            end
        end
        espState.boxes = {}
    end

    -- Draw ESP box for a player
    local function drawESP(player)
        local box = Drawing.new("Square")
        box.Thickness = espState.thickness
        box.Filled = false
        box.Color = Color3.new(1, 1, 1)
        box.Visible = false

        espState.boxes[player] = box
    end

    -- Remove box for a player
    local function removeESP(player)
        if espState.boxes[player] then
            espState.boxes[player]:Remove()
            espState.boxes[player] = nil
        end
    end

    -- ESP render logic
    if enabled then
        for _, p in pairs(Players:GetPlayers()) do
            if p ~= LocalPlayer and p.Team ~= LocalPlayer.Team and not espState.boxes[p] then
                drawESP(p)
            end
        end

        Players.PlayerAdded:Connect(function(p)
            if p ~= LocalPlayer and p.Team ~= LocalPlayer.Team then
                drawESP(p)
            end
        end)

        Players.PlayerRemoving:Connect(function(p)
            removeESP(p)
        end)

        RunService.RenderStepped:Connect(function()
            for _, p in pairs(Players:GetPlayers()) do
                if espState.boxes[p] and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = p.Character.HumanoidRootPart
                    local head = p.Character:FindFirstChild("Head")

                    if head then
                        local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                        if onScreen and espState.showBoxes then
                            local scale = 3
                            local box = espState.boxes[p]
                            box.Size = Vector2.new(35, 50) / (hrp.Position - Camera.CFrame.Position).Magnitude * scale
                            box.Position = Vector2.new(screenPos.X - box.Size.X/2, screenPos.Y - box.Size.Y/1.5)
                            box.Visible = true
                            if espState.dynamicColor then
                                box.Color = Color3.new(1, 0, 0)
                            else
                                box.Color = Color3.new(1, 1, 1)
                            end
                            box.Thickness = espState.thickness
                        else
                            espState.boxes[p].Visible = false
                        end
                    end
                end
            end
        end)
    else
        clearESP()
    end

    -- Show/hide ESP settings in GUI
    if not espState.settingsInitialized then
        espState.settingsInitialized = true

        table.insert(espState.settingsObjects, Ren:CreateSlider("Box Thickness", function(val)
            espState.thickness = val
        end, 1, 5, nil, false, espState.thickness))

        table.insert(espState.settingsObjects, Ren:CreateSwitch("Dynamic Color", function(toggle)
            espState.dynamicColor = toggle
        end))

        table.insert(espState.settingsObjects, Ren:CreateSwitch("Show Boxes", function(toggle)
            espState.showBoxes = toggle
        end))
    end

    for _, setting in pairs(espState.settingsObjects) do
        if setting and setting.Frame then
            setting.Frame.Visible = enabled
        end
    end

    print("ðŸ‘€ ESP is now " .. (enabled and "enabled" or "disabled"))
end)

Uti = gui:CreateCategory("Utility")

Wor = gui:CreateCategory("World")

Exe = gui:CreateCategory("Executor")


Exe:CreateButton("Open Executor", function()
    local screenGui = Instance.new("ScreenGui", game.CoreGui)
    screenGui.Name = "ScriptConsole_" .. tostring(math.random(1000, 9999))
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local frame = Instance.new("Frame", screenGui)
    frame.Size = UDim2.new(0, 400, 0, 300)
    frame.Position = UDim2.new(0.5, -200, 0.5, -150)
    frame.BackgroundColor3 = Color3.new(0, 0, 0)
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Draggable = true

    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 12)

    local topBar = Instance.new("Frame", frame)
    topBar.Size = UDim2.new(1, 0, 0, 30)
    topBar.Position = UDim2.new(0, 0, 0, 0)
    topBar.BackgroundTransparency = 1

    local function createTopButton(name, text, posOffset)
        local btn = Instance.new("TextButton", topBar)
        btn.Size = UDim2.new(0, 30, 0, 30)
        btn.Position = UDim2.new(1, -30 * posOffset, 0, 0)
        btn.BackgroundColor3 = Color3.new(1, 1, 1)
        btn.TextColor3 = Color3.new(0, 0, 0)
        btn.Font = Enum.Font.SourceSansBold
        btn.TextSize = 18
        btn.Text = text
        btn.Name = name
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        return btn
    end

    local closeBtn = createTopButton("Close", "X", 1)
    local minimizeBtn = createTopButton("Minimize", "-", 2)
    local maximizeBtn = createTopButton("Maximize", "â–¢", 3)

    local textBox = Instance.new("TextBox", frame)
    textBox.Size = UDim2.new(1, -20, 1, -90)
    textBox.Position = UDim2.new(0, 10, 0, 40)
    textBox.BackgroundColor3 = Color3.new(0, 0, 0)
    textBox.TextColor3 = Color3.new(1, 1, 1)
    textBox.ClearTextOnFocus = false
    textBox.MultiLine = true
    textBox.TextXAlignment = Enum.TextXAlignment.Left
    textBox.TextYAlignment = Enum.TextYAlignment.Top
    textBox.Font = Enum.Font.Code
    textBox.TextSize = 14
    textBox.Text = ""
    textBox.PlaceholderText = 'print("Temic!")'
    Instance.new("UICorner", textBox).CornerRadius = UDim.new(0, 8)

    local executeBtn = Instance.new("TextButton", frame)
    executeBtn.Size = UDim2.new(0.5, -15, 0, 40)
    executeBtn.Position = UDim2.new(0, 10, 1, -45)
    executeBtn.Text = "Execute"
    executeBtn.BackgroundColor3 = Color3.new(1, 1, 1)
    executeBtn.TextColor3 = Color3.new(0, 0, 0)
    executeBtn.Font = Enum.Font.SourceSansBold
    executeBtn.TextSize = 18
    Instance.new("UICorner", executeBtn).CornerRadius = UDim.new(0, 8)

    local clearBtn = Instance.new("TextButton", frame)
    clearBtn.Size = UDim2.new(0.5, -15, 0, 40)
    clearBtn.Position = UDim2.new(0.5, 5, 1, -45)
    clearBtn.Text = "Clear"
    clearBtn.BackgroundColor3 = Color3.new(1, 1, 1)
    clearBtn.TextColor3 = Color3.new(0, 0, 0)
    clearBtn.Font = Enum.Font.SourceSansBold
    clearBtn.TextSize = 18
    Instance.new("UICorner", clearBtn).CornerRadius = UDim.new(0, 8)

    executeBtn.MouseButton1Click:Connect(function()
        local success, err = pcall(function()
            local func = loadstring(textBox.Text)
            if func then func() end
        end)
        if not success then
            warn("Script error:", err)
        end
    end)

    clearBtn.MouseButton1Click:Connect(function()
        textBox.Text = ""
    end)

    closeBtn.MouseButton1Click:Connect(function()
        screenGui:Destroy()
    end)

    local minimized = false
    local originalSize = frame.Size

    minimizeBtn.MouseButton1Click:Connect(function()
        if not minimized then
            frame.Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset, 0, 40)
            textBox.Visible = false
            executeBtn.Visible = false
            clearBtn.Visible = false
            minimized = true
        end
    end)

    maximizeBtn.MouseButton1Click:Connect(function()
        if minimized then
            frame.Size = originalSize
            textBox.Visible = true
            executeBtn.Visible = true
            clearBtn.Visible = true
            minimized = false
        end
    end)
end)

-- âœ… Auto re-execute on teleport
local TeleportService = game:GetService("TeleportService")
queueonteleport([[
loadstring(game:HttpGet("https://raw.githubusercontent.com/ClownyCoder/WIP/refs/heads/main/WIP"))()
]])
